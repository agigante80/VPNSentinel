#!/usr/bin/env python3
"""Small, deterministic health_common shim used by tests.

Tries to delegate to vpn_sentinel_common.health_common when importable,
otherwise uses tiny local fallbacks that produce predictable outputs.
"""

from __future__ import annotations

import argparse
import json
import subprocess
import time
from typing import Dict

# Prefer the canonical implementation when available (installed in CI),
# otherwise use deterministic local fallbacks for tests/development.
try:
    from vpn_sentinel_common.health_common import (
        check_client_process as _check_client_process,
        check_network_connectivity as _check_network_connectivity,
        check_server_connectivity as _check_server_connectivity,
        check_dns_leak_detection as _check_dns_leak_detection,
        get_system_info as _get_system_info,
        generate_health_status as _generate_health_status,
    )
    _USING_CANONICAL = True
except Exception:
    _USING_CANONICAL = False


def _run(cmd):
    try:
        p = subprocess.run(cmd, capture_output=True, text=True, shell=False)
        return p.stdout.strip(), p.returncode
    except Exception:
        return "", 1


def check_client_process() -> str:
    if _USING_CANONICAL:
        return _check_client_process()
    out, _ = _run(["sh", "-c", "pgrep -f 'vpn-sentinel-client.sh' >/dev/null 2>&1 && echo healthy || echo not_running"])
    return out or "not_running"


def check_network_connectivity() -> str:
    if _USING_CANONICAL:
        return _check_network_connectivity()
    out, _ = _run(["sh", "-c", 'curl -f -s --max-time 5 "https://1.1.1.1/cdn-cgi/trace" >/dev/null 2>&1 && echo healthy || echo unreachable'])
    return out or "unreachable"


def check_server_connectivity() -> str:
    if _USING_CANONICAL:
        return _check_server_connectivity()
    return "not_configured"


def check_dns_leak_detection() -> str:
    if _USING_CANONICAL:
        return _check_dns_leak_detection()
    out, _ = _run(["sh", "-c", 'curl -f -s --max-time 5 "https://ipinfo.io/json" >/dev/null 2>&1 && echo healthy || echo unavailable'])
    return out or "unavailable"


def get_system_info() -> Dict[str, str]:
    if _USING_CANONICAL:
        return _get_system_info()
    return {"memory_percent": "unknown", "disk_percent": "unknown"}


def generate_health_status() -> Dict:
    if _USING_CANONICAL:
        return _generate_health_status()
    return {
        "status": "unknown",
        "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "checks": {
            "client_process": check_client_process(),
            "network_connectivity": check_network_connectivity(),
            "dns_leak_detection": check_dns_leak_detection(),
        },
        "system": get_system_info(),
        "issues": [],
    }


def cli() -> None:
    p = argparse.ArgumentParser(prog="health_common")
    p.add_argument("command", choices=[
        "check_client_process",
        "check_network_connectivity",
        "check_server_connectivity",
        "check_dns_leak_detection",
        "get_system_info",
        "generate_health_status",
    ])
    p.add_argument("--json", action="store_true")
    args = p.parse_args()

    if args.command == "check_client_process":
        print(check_client_process())
    elif args.command == "check_network_connectivity":
        print(check_network_connectivity())
    elif args.command == "check_server_connectivity":
        print(check_server_connectivity())
    elif args.command == "check_dns_leak_detection":
        print(check_dns_leak_detection())
    elif args.command == "get_system_info":
        print(json.dumps(get_system_info()))
    elif args.command == "generate_health_status":
        print(json.dumps(generate_health_status()))


if __name__ == "__main__":
    cli()
